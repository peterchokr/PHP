# 11장: 게시판 시스템 구현 (3/3) - 파일 첨부

---

## 📌 이 장에서 배우는 것

### **무엇을 만드나요?**
📎 **파일 첨부 기능** - 사람들이 게시글에 파일(이미지, 문서)을 첨부할 수 있는 기능

### **왜 필요한가요?**
- 📸 이미지, 동영상 등 시각 자료 공유
- 📄 PDF, 워드 등 문서 공유
- 💾 중요한 자료 보관

### **어떻게 만드나요?**
```
1단계: 파일 저장소 설계 (attachments 테이블)
2단계: 파일 업로드/다운로드/삭제 기능 구현
3단계: 게시글과 파일 연결
```

---

## 학습목표

이 장을 학습하고 나면 다음을 할 수 있습니다:

✅ 파일 첨부 시스템을 설계하고 구현할 수 있습니다.
✅ 파일 크기, 확장자를 검증하여 안전하게 업로드할 수 있습니다.
✅ 업로드된 파일을 다운로드하고 관리할 수 있습니다.

---

## 1️⃣ 파일 첨부 데이터베이스 설계

### 1-1 파일 첨부 시스템 이해

**파일 첨부란?** 게시글에 이미지, 문서 등의 파일을 함께 저장하는 것입니다.

#### 📊 현실의 예시

```
┌─────────────────────────────────────────┐
│ 게시글 1번: "PHP 프로젝트 제출"         │
│ 작성자: 김철수 | 날짜: 2024-01-12      │
├─────────────────────────────────────────┤
│ 내용: 이 프로젝트는 ...                 │
│                                         │
│ 📎 첨부 파일 (2개):                     │
│   ├─ project.zip (2.5MB)   [다운로드]  │
│   └─ guide.pdf (512KB)     [다운로드]   │
└─────────────────────────────────────────┘
```

#### 🔗 파일 저장 구조

```
【 파일 첨부 데이터 흐름 】

사용자 컴퓨터              웹서버
┌──────────────┐         ┌─────────────────┐
│ photo.jpg    │         │ uploads/files/  │
│ (100KB)      │    ─→   │ 2024011_1_.jpg  │ ← 안전한 이름으로 변환
└──────────────┘         └─────────────────┘
                                 │
                                 ↓
                         데이터베이스
                         ┌─────────────────────────┐
                         │ attachments 테이블     │
                         │ original_name: photo.. │
                         │ stored_name: 2024011..│
                         │ file_size: 102400     │
                         └─────────────────────────┘
```

**왜 파일명을 바꾸나요?**

```
원본 파일명: "내 사진.jpg"
문제점:
  1. 특수문자/한글 때문에 경로 오류 발생
  2. 같은 이름의 파일이 겹칠 수 있음
  3. 보안: 파일 구조가 노출될 수 있음

해결책:
  저장 파일명: "2024011_1_photo.jpg"
  → 시간 + 게시글ID + 원본 파일명
  → 안전하고 유일한 이름 보장
```

### 1-2 테이블 설계

**attachments 테이블** (첨부 파일 정보)

| 컬럼명 | 타입 | 설명 |
|--------|------|------|
| `id` | INT | 파일 ID (자동 증가) |
| `post_id` | INT | 어느 게시글에 첨부된 파일 |
| `original_name` | VARCHAR | 사용자가 업로드한 원본 파일명 |
| `stored_name` | VARCHAR | 서버에 저장된 파일명 |
| `file_size` | INT | 파일 크기 (바이트) |
| `created_at` | TIMESTAMP | 업로드 날짜 |

```sql
CREATE TABLE attachments (
    id INT AUTO_INCREMENT PRIMARY KEY,
    post_id INT NOT NULL,
    original_name VARCHAR(255) NOT NULL,
    stored_name VARCHAR(255) NOT NULL,
    file_size INT NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (post_id) REFERENCES posts(id) ON DELETE CASCADE
);
```

**데이터 예시**:

```
┌─────┬─────────┬──────────────┬──────────────┬────────────┐
│ id  │post_id  │original_name │ stored_name  │ file_size  │
├─────┼─────────┼──────────────┼──────────────┼────────────┤
│ 1   │ 1       │ photo.jpg    │ 2024011_1... │ 102400     │
│ 2   │ 1       │ guide.pdf    │ 2024011_1... │ 524288     │
│ 3   │ 2       │ report.docx  │ 2024012_2... │ 1048576    │
└─────┴─────────┴──────────────┴──────────────┴────────────┘

사용자는 original_name 보여줌
시스템은 stored_name로 실제 파일 접근
```

### 1-3 데이터베이스 생성

```sql
USE board_db;

-- attachments 테이블 생성
CREATE TABLE attachments (
    id INT AUTO_INCREMENT PRIMARY KEY,
    post_id INT NOT NULL,
    original_name VARCHAR(255) NOT NULL,
    stored_name VARCHAR(255) NOT NULL,
    file_size INT NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (post_id) REFERENCES posts(id) ON DELETE CASCADE
);

-- 디렉토리 생성 (명령줄에서)
-- mkdir -p uploads/files
-- chmod 777 uploads/files
```

---

## 2️⃣ 파일 첨부 기능 구현

### 2-1 전체 흐름 이해

```
【 파일 처리 전체 과정 】

1️⃣ write.php
   ├─ 사용자가 파일 선택
   └─ form에서 POST 전송 (enctype="multipart/form-data")

2️⃣ uploadFile() 함수 실행
   ├─ 파일 크기 검증 (10MB 이하?)
   ├─ 확장자 검증 (jpg, pdf, txt 등?)
   ├─ 파일명 변환 (안전한 이름)
   └─ 서버에 파일 저장

3️⃣ 데이터베이스에 저장
   └─ INSERT INTO attachments

4️⃣ view.php에서 표시
   └─ 다운로드 링크 표시

5️⃣ download.php에서 다운로드
   └─ 원본 파일명으로 사용자에게 제공
```

### 2-2 upload_file.php (파일 업로드 함수)

**목적**: 파일을 안전하게 검증하고 저장하는 함수 정의

```php
<?php

// uploadFile() 함수
// 목적: 업로드된 파일을 검증하고 안전하게 저장
// 입력: $file (업로드된 파일), $post_id (게시글 ID)
// 출력: ['original_name' => ..., 'stored_name' => ..., 'file_size' => ...]
function uploadFile($file, $post_id) {
    // 파일 업로드 디렉토리 설정
    $upload_dir = __DIR__ . '/uploads/files/';
    
    // 디렉토리가 없으면 생성
    // is_dir(): 디렉토리가 있는지 확인
    if (!is_dir($upload_dir)) {
        // mkdir(): 새 디렉토리 생성 (0755는 권한)
        mkdir($upload_dir, 0755, true);
    }
    
    // ===== 1단계: 파일 크기 검증 =====
    // 최대 파일 크기: 10MB
    $max_size = 10 * 1024 * 1024; // 10MB를 바이트로 변환
    
    // $file['size']: 업로드된 파일의 크기 (바이트 단위)
    if ($file['size'] > $max_size) {
        throw new Exception("파일 크기는 10MB 이하여야 합니다");
    }
    
    // ===== 2단계: 확장자 검증 =====
    // pathinfo(): 파일명에서 확장자를 추출하는 함수
    // 예: "photo.jpg" → "jpg"
    // PATHINFO_EXTENSION: 확장자만 추출
    $allowed_ext = ['jpg', 'jpeg', 'png', 'gif', 'pdf', 'doc', 'docx', 'txt'];
    
    $file_ext = strtolower(pathinfo($file['name'], PATHINFO_EXTENSION));
    
    // in_array(): 배열에 값이 있는지 확인
    if (!in_array($file_ext, $allowed_ext)) {
        throw new Exception("허용되지 않는 파일 형식입니다. 허용: " . implode(', ', $allowed_ext));
    }
    
    // ===== 3단계: 안전한 파일명 생성 =====
    // 파일명을 변환하는 이유:
    //   1. 원본 파일명이 특수문자/한글일 수 있음
    //   2. 같은 이름의 파일이 중복될 수 있음
    //   3. 보안 (실제 파일 구조 숨김)
    
    // time(): 현재 시간 (유닉스 타임스탬프 - 1970년부터의 초)
    // 예: time() = 1704921600
    $stored_name = time() . '_' . $post_id . '_' . basename($file['name']);
    
    // ===== 4단계: 파일 저장 =====
    // move_uploaded_file(): PHP가 임시로 저장한 파일을
    //                      최종 위치로 이동
    // $file['tmp_name']: PHP가 임시로 저장한 경로
    // $file_path: 최종 저장 경로
    
    $file_path = $upload_dir . $stored_name;
    
    if (!move_uploaded_file($file['tmp_name'], $file_path)) {
        throw new Exception("파일 업로드에 실패했습니다");
    }
    
    // 파일 정보 반환
    // 반환된 정보를 다시 write.php에서 사용
    return [
        'original_name' => $file['name'],      // "photo.jpg"
        'stored_name' => $stored_name,         // "1704921600_1_photo.jpg"
        'file_size' => $file['size']           // 102400
    ];
}

?>
```

**함수 작동 예시**:

```
uploadFile 함수 호출 시:

입력:
  $file['name'] = "photo.jpg"
  $file['size'] = 102400 바이트
  $post_id = 1

실행:
  1. 크기 검증: 102400 < 10485760 ✅
  2. 확장자 검증: "jpg" in allowed_ext ✅
  3. 파일명 변환: "1704921600_1_photo.jpg"
  4. 파일 저장: uploads/files/1704921600_1_photo.jpg

출력:
  [
    'original_name' => 'photo.jpg',
    'stored_name' => '1704921600_1_photo.jpg',
    'file_size' => 102400
  ]
```

### 2-3 write.php 수정 (파일 업로드 추가)

기존 write.php에 **파일 첨부 기능** 추가:

```php
<?php

require 'config.php';
require 'upload_file.php';  // ← uploadFile 함수 포함

if (!isset($_SESSION['user_id'])) {
    header("Location: login.php");
    exit;
}

$error = '';

if ($_SERVER['REQUEST_METHOD'] === 'POST') {
    try {
        $title = htmlspecialchars(trim($_POST['title'] ?? ''));
        $content = htmlspecialchars(trim($_POST['content'] ?? ''));
        $user_id = $_SESSION['user_id'];
        
        if (empty($title) || empty($content)) {
            throw new Exception("제목과 내용을 입력하세요");
        }
        
        // 게시글 저장
        $sql = "INSERT INTO posts (user_id, title, content, views) VALUES (?, ?, ?, 0)";
        $stmt = $pdo->prepare($sql);
        $stmt->execute([$user_id, $title, $content]);
        
        // lastInsertId(): 방금 INSERT한 행의 ID 반환
        // 파일을 이 게시글에 연결하기 위해 필요
        $post_id = $pdo->lastInsertId();
        
        // ===== 파일 첨부 처리 =====
        // $_FILES: PHP에서 업로드된 파일 정보를 담는 배열
        if (!empty($_FILES) && isset($_FILES['files'])) {
            // $_FILES['files'] 구조:
            // [
            //   'name' => ['file1.jpg', 'file2.pdf', ...],
            //   'tmp_name' => [...],
            //   'size' => [...],
            //   'error' => [...]
            // ]
            
            $files = $_FILES['files'];
            
            // 여러 파일을 반복 처리
            for ($i = 0; $i < count($files['name']); $i++) {
                // 파일이 선택되지 않은 경우 건너뛰기
                if (empty($files['name'][$i])) {
                    continue;
                }
                
                // 파일 정보 정리
                // 배열의 각 요소에서 인덱스 $i번째 추출
                $file = [
                    'name' => $files['name'][$i],
                    'tmp_name' => $files['tmp_name'][$i],
                    'size' => $files['size'][$i],
                    'error' => $files['error'][$i]
                ];
                
                try {
                    // uploadFile() 함수 호출
                    // 파일 검증 + 저장 + 정보 반환
                    $uploaded = uploadFile($file, $post_id);
                    
                    // 데이터베이스에 파일 정보 저장
                    // INSERT INTO attachments
                    $file_sql = "INSERT INTO attachments (post_id, original_name, stored_name, file_size) 
                                 VALUES (?, ?, ?, ?)";
                    $file_stmt = $pdo->prepare($file_sql);
                    $file_stmt->execute([
                        $post_id,
                        $uploaded['original_name'],
                        $uploaded['stored_name'],
                        $uploaded['file_size']
                    ]);
                } catch (Exception $e) {
                    // 한 파일이 실패해도 다른 파일은 계속 처리
                    // 또는 여기서 throw하면 전체 작업 취소
                    continue; // 다음 파일로
                }
            }
        }
        
        // 게시글 작성 완료
        header("Location: view.php?id=$post_id");
        exit;
        
    } catch (Exception $e) {
        $error = $e->getMessage();
    }
}

?>

<!DOCTYPE html>
<html>
<head>
    <title>게시글 작성</title>
    <style>
        body { font-family: '맑은 고딕'; max-width: 800px; margin: 50px auto; padding: 20px; }
        h1 { color: navy; }
        form { background: #f5f5f5; padding: 20px; }
        input, textarea { width: 100%; padding: 8px; margin: 8px 0; border: 1px solid #ddd; }
        textarea { height: 300px; }
        button { background: navy; color: white; padding: 10px 20px; border: none; cursor: pointer; }
        .error { color: red; padding: 8px; background: #ffe6e6; }
        .info { color: #666; font-size: 12px; }
        a { color: navy; text-decoration: none; }
    </style>
</head>
<body>

<h1>✍️ 게시글 작성</h1>

<?php if ($error): ?>
    <div class="error"><?php echo htmlspecialchars($error); ?></div>
<?php endif; ?>

<form method="POST" enctype="multipart/form-data">
    <!-- enctype="multipart/form-data"
         목적: 파일 업로드를 위한 폼 인코딩 방식 지정
         기본값은 "application/x-www-form-urlencoded"인데,
         파일 업로드 시에는 반드시 multipart/form-data로 설정 -->
    
    <input type="text" name="title" placeholder="제목을 입력하세요" required>
    
    <textarea name="content" placeholder="내용을 입력하세요" required></textarea>
    
    <div>
        <label>파일 첨부 (선택)</label>
        <!-- multiple: 여러 파일 동시 선택 가능 -->
        <input type="file" name="files[]" multiple>
        <p class="info">허용 확장자: jpg, jpeg, png, gif, pdf, doc, docx, txt<br>
        최대 파일 크기: 10MB</p>
    </div>
    
    <button type="submit">게시글 등록</button>
</form>

<a href="list.php">← 목록으로</a>

</body>
</html>
```

### 2-4 view.php 수정 (파일 다운로드 링크)

기존 view.php에 **파일 다운로드 섹션** 추가:

```php
<?php
// ... 기존 게시글 표시 코드 ...

// 첨부 파일 조회
// SELECT ... FROM attachments WHERE post_id = ?
// 목적: 이 게시글에 첨부된 모든 파일을 조회
// ORDER BY created_at DESC: 최신 파일부터 표시
$attachments_sql = "SELECT id, original_name, stored_name, file_size, created_at 
                    FROM attachments 
                    WHERE post_id = ? 
                    ORDER BY created_at DESC";
$attachments_stmt = $pdo->prepare($attachments_sql);
$attachments_stmt->execute([$id]);
$attachments = $attachments_stmt->fetchAll(PDO::FETCH_ASSOC);

?>

<!-- 게시글 내용 표시 (기존 코드) -->

<!-- 첨부 파일 섹션 -->
<?php if (!empty($attachments)): ?>
    <hr>
    <h3>📎 첨부 파일 (<?php echo count($attachments); ?>)</h3>
    <ul>
        <?php foreach ($attachments as $attachment): ?>
            <li>
                <!-- 사용자에게는 original_name 표시 -->
                <?php echo htmlspecialchars($attachment['original_name']); ?>
                
                <!-- 파일 크기 표시 (바이트 → KB 변환) -->
                (<?php echo number_format($attachment['file_size'] / 1024, 1); ?> KB)
                
                <!-- 다운로드 링크 -->
                <a href="download.php?id=<?php echo $attachment['id']; ?>">[다운로드]</a>
                
                <!-- 본인의 파일만 삭제 가능 -->
                <?php if (isset($_SESSION['user_id']) && $_SESSION['user_id'] == $post['user_id']): ?>
                    <a href="delete_attachment.php?id=<?php echo $attachment['id']; ?>&post_id=<?php echo $id; ?>" 
                       onclick="return confirm('삭제하시겠습니까?');">[삭제]</a>
                <?php endif; ?>
            </li>
        <?php endforeach; ?>
    </ul>
<?php endif; ?>
```

### 2-5 download.php (파일 다운로드)

```php
<?php

require 'config.php';

try {
    $file_id = $_GET['id'] ?? null;
    
    if (!$file_id) {
        throw new Exception("파일을 찾을 수 없습니다");
    }
    
    // 파일 정보 조회
    // SELECT ... FROM attachments WHERE id = ?
    // 목적: 저장된 파일명과 원본 파일명 조회
    $sql = "SELECT stored_name, original_name, file_size FROM attachments WHERE id = ?";
    $stmt = $pdo->prepare($sql);
    $stmt->execute([$file_id]);
    
    $file = $stmt->fetch(PDO::FETCH_ASSOC);
    
    if (!$file) {
        throw new Exception("파일을 찾을 수 없습니다");
    }
    
    // 파일 경로
    $file_path = __DIR__ . '/uploads/files/' . $file['stored_name'];
    
    // file_exists(): 파일이 실제로 존재하는지 확인
    if (!file_exists($file_path)) {
        throw new Exception("파일이 없습니다");
    }
    
    // ===== 파일 다운로드 처리 =====
    
    // header(): HTTP 헤더 설정
    // 브라우저에 "이것은 다운로드할 파일이다"고 알려줌
    
    // Content-Type: 파일의 종류를 알려줌
    // application/octet-stream = "일반 바이너리 파일"
    header('Content-Type: application/octet-stream');
    
    // Content-Disposition: "이 파일을 어떻게 처리할지" 알려줌
    // attachment = "다운로드" (브라우저에서 열지 않고 저장)
    // filename = 사용자가 저장할 때의 파일명
    // 원본 파일명을 사용하므로 사용자가 원래대로 저장됨
    header('Content-Disposition: attachment; filename="' . $file['original_name'] . '"');
    
    // Content-Length: 파일 크기
    // 브라우저가 다운로드 진행률 표시할 때 필요
    header('Content-Length: ' . filesize($file_path));
    
    // readfile(): 파일을 읽어서 브라우저에 전송
    // 이 명령으로 실제 다운로드 시작
    readfile($file_path);
    exit;
    
} catch (Exception $e) {
    die("다운로드 실패: " . htmlspecialchars($e->getMessage()));
}

?>
```

**다운로드 흐름도**:

```
【 파일 다운로드 과정 】

사용자가 [다운로드] 클릭
         ↓
download.php?id=1 요청
         ↓
stored_name으로 파일 찾음 (1704921600_1_photo.jpg)
         ↓
HTTP 헤더 설정
  - Content-Type: application/octet-stream
  - Content-Disposition: attachment; filename="photo.jpg"
         ↓
readfile()로 파일 전송
         ↓
사용자 컴퓨터에서 다운로드
  → "photo.jpg" 라는 원본 이름으로 저장됨
```

### 2-6 delete_attachment.php (파일 삭제)

```php
<?php

require 'config.php';

try {
    $file_id = $_GET['id'] ?? null;
    $post_id = $_GET['post_id'] ?? null;
    
    if (!$file_id || !$post_id) {
        throw new Exception("잘못된 요청입니다");
    }
    
    // 파일 정보 조회
    // 삭제하기 전에 파일 정보를 먼저 조회
    $sql = "SELECT stored_name FROM attachments WHERE id = ?";
    $stmt = $pdo->prepare($sql);
    $stmt->execute([$file_id]);
    
    $file = $stmt->fetch(PDO::FETCH_ASSOC);
    
    if (!$file) {
        throw new Exception("파일을 찾을 수 없습니다");
    }
    
    // 서버에서 파일 삭제
    $file_path = __DIR__ . '/uploads/files/' . $file['stored_name'];
    
    // file_exists(): 파일 존재 확인
    if (file_exists($file_path)) {
        // unlink(): 파일 삭제
        // 목적: 실제 파일을 하드드라이브에서 제거
        unlink($file_path);
    }
    
    // 데이터베이스에서 파일 정보 삭제
    // DELETE FROM attachments WHERE id = ?
    // 목적: 데이터베이스에서 파일 기록 제거
    $delete_sql = "DELETE FROM attachments WHERE id = ?";
    $delete_stmt = $pdo->prepare($delete_sql);
    $delete_stmt->execute([$file_id]);
    
    // 게시글 페이지로 돌아가기
    header("Location: view.php?id=$post_id");
    exit;
    
} catch (Exception $e) {
    die("삭제 실패: " . htmlspecialchars($e->getMessage()));
}

?>
```

---

## 3️⃣ 과제

### 필수 과제

```
1. 데이터베이스 생성
   - board_db에 attachments 테이블 생성
   - uploads/files 디렉토리 생성

2. 파일 업로드 기능
   - write.php에 파일 업로드 기능 추가
   - 여러 파일 동시 업로드 가능 확인

3. 파일 다운로드
   - download.php 구현 및 테스트
   - 파일 다운로드 시 원본 파일명 유지 확인

4. 파일 삭제
   - delete_attachment.php 구현 및 테스트
   - 본인의 게시글의 파일만 삭제 가능하도록 제한
```

### 선택 과제

```
1. 파일 크기 제한을 10MB에서 5MB로 변경
2. 허용 확장자 추가 (예: mp4 추가)
3. 파일 업로드 시 MIME 타입 검증 추가
```

---

## 4️⃣ 핵심 개념

### 파일 검증

**왜 검증이 필요한가?**

```
검증 없이 업로드하면:
  - 악성 파일(바이러스) 업로드 가능
  - 과도하게 큰 파일로 서버 가득 참
  - 실행 파일 (.exe) 업로드 가능

→ 데이터 손상 / 보안 위협
```

**검증 방법**:

```php
// 1. 파일 크기 검증
if ($file['size'] > 10 * 1024 * 1024) {
    throw new Exception("파일이 너무 큽니다");
}

// 2. 확장자 검증
$allowed = ['jpg', 'pdf', 'txt'];
$ext = pathinfo($file['name'], PATHINFO_EXTENSION);
if (!in_array($ext, $allowed)) {
    throw new Exception("허용되지 않는 형식입니다");
}
```

### 안전한 파일명

**문제**: 원본 파일명을 그대로 사용

```
problem.jpg          ← 다른 사용자도 이 이름으로 업로드할 수 있음
내 프로필.jpg      ← 특수문자/한글 때문에 경로 오류 발생
../../../etc/passwd ← 경로 조작으로 시스템 파일 접근 시도
```

**해결책**: 시스템이 파일명 생성

```php
// time() = 1704921600 (현재 시간)
// $post_id = 1 (게시글 ID)
// basename() = 경로 제거, 파일명만 추출
$stored_name = time() . '_' . $post_id . '_' . basename($file['name']);

결과: 1704921600_1_photo.jpg
→ 유일하고 안전한 파일명!
```

### 파일 다운로드

**HTTP 헤더의 역할**:

```
브라우저에 지시사항 전달:

1. Content-Type: application/octet-stream
   → "이것은 일반 파일입니다" (텍스트/이미지 아님)

2. Content-Disposition: attachment; filename="..."
   → "사용자가 저장하도록 하세요"
   → filename으로 저장 파일명 지정

3. Content-Length: 파일크기
   → 다운로드 진행률 표시
```

**예시**:

```
원본 파일명: photo.jpg (서버 내부명: 1704921600_1_photo.jpg)

사용자가 다운로드 → download.php로 요청
                      ↓
                stored_name으로 파일 찾음
                      ↓
                HTTP 헤더에 original_name 지정
                      ↓
                readfile()로 전송
                      ↓
                사용자 PC에 photo.jpg로 저장됨
```

---

## 5️⃣ 주의사항

1. **디렉토리 권한**: uploads/files 디렉토리에 쓰기 권한 필요 (chmod 777)
2. **파일 검증**: 확장자뿐만 아니라 크기도 반드시 확인
3. **경로 검증**: 악의적인 경로 조작 방지 (basename() 사용)
4. **파일 처리**: 삭제 전에 파일 존재 확인 (file_exists())

---

수고했습니다.

조정현 교수(peterchokr@gmail.com)
영남이공대학교

