# 11장: 게시판 시스템 구현 (3/3) - 파일 첨부

---

## 📌 이 장에서 배우는 것

### **무엇을 만드나요?**
📎 **파일 첨부 기능** - 사람들이 게시글에 파일(이미지, 문서)을 첨부할 수 있는 기능

### **왜 필요한가요?**
- 📸 이미지, 동영상 등 시각 자료 공유
- 📄 PDF, 워드 등 문서 공유
- 💾 중요한 자료 보관

### **어떻게 만드나요?**
```
1단계: 파일 저장소 설계 (attachments 테이블)
2단계: 파일 업로드/다운로드/삭제 기능 구현
3단계: 게시글과 파일 연결
```

---

## 학습목표

이 장을 학습하고 나면 다음을 할 수 있습니다:

✅ 파일 첨부 시스템을 설계하고 구현할 수 있습니다.
✅ 파일 크기, 확장자를 검증하여 안전하게 업로드할 수 있습니다.
✅ 업로드된 파일을 다운로드하고 관리할 수 있습니다.

---



---



---

## ⚠️ 중요: 선행 조건

이 장을 진행하기 전에 다음을 완료하세요:

```
✅ 10장 완료: 댓글 기능 구현
   - config.php 작성
   - login.php 작성
   - logout.php 작성
   - setup_users.php 실행 (테스트 사용자 생성)
```

**11장에서 사용하는 것들:**
- config.php (DB 연결 + 세션)
- login.php (사용자 로그인)
- $_SESSION['user_id'] (현재 로그인한 사용자)
- password_verify() (bcrypt 비밀번호 검증)

---

## ⚠️ 필수 사전 준비: 로그인 + 파일 업로드

**이 장을 진행하기 전에 반드시 읽으세요!**

### 선행 조건

이 장의 모든 코드는 다음을 기반으로 합니다:

```
✅ 10장 완료 (댓글 기능)
✅ config.php 작성 완료 (DB 연결 + 세션)
✅ login.php 작성 완료 (사용자 로그인)
✅ 테스트 사용자 생성 완료
```

**필요한 파일:**
- config.php (DB 연결 + 세션)
- login.php (로그인)
- logout.php (로그아웃)
- setup_users.php (테스트 사용자) - 이미 10장에서 생성됨

---

## 0️⃣ 파일 업로드 헬퍼 함수 (upload_file.php)

### 0-1 upload_file.php 함수 설명

파일 업로드를 안전하게 처리하는 함수입니다.

**주요 기능:**

```
uploadFile($file, $post_id):
├─ 파일 크기 검증 (최대 10MB)
├─ 파일 확장자 검증 (jpg, png, pdf, doc, docx, txt, gif)
├─ 파일명 안전하게 변환 (타임스탐프_포스트ID_파일명)
├─ 파일 저장 (uploads/files/ 디렉토리)
└─ 파일 정보 반환 (original_name, stored_name, file_size)

사용 예시:
require 'upload_file.php';
$file_info = uploadFile($_FILES['file'], $post_id);
```

**📝 상세한 코드:**

상세한 uploadFile() 함수 코드는 아래 **2-2 upload_file.php** 섹션을 참고하세요.

**⚠️ 다운로드 함수:**

파일 다운로드는 **upload_file.php**에서 함수로 제공하지 않고,
**2-5 download.php** 파일에서 직접 구현합니다.

이유: 다운로드는 HTTP 헤더 처리가 복잡하여 별도 파일에서 처리하는 것이 안전합니다.

### 0-2 uploads 디렉토리 생성 (필수!)

파일을 저장할 디렉토리를 생성하세요.

**Linux/Mac:**
```bash
mkdir -p boards/uploads/files
chmod 777 boards/uploads/files
```

**또는 PHP 파일로:**

```php
<?php
// test_dir.php
$upload_dir = __DIR__ . '/uploads/files/';

if (!is_dir($upload_dir)) {
    if (mkdir($upload_dir, 0755, true)) {
        echo "디렉토리 생성 완료";
    } else {
        echo "디렉토리 생성 실패";
    }
} else {
    echo "디렉토리가 이미 존재합니다";
}
?>
```

브라우저에서 실행: http://localhost/boards/test_dir.php

---

## 1️⃣ 파일 첨부 데이터베이스 설계

### 1-1 파일 첨부 시스템 이해

**파일 첨부란?** 게시글에 이미지, 문서 등의 파일을 함께 저장하는 것입니다.

#### 📊 현실의 예시

```
┌─────────────────────────────────────────┐
│ 게시글 1번: "PHP 프로젝트 제출"         │
│ 작성자: 김철수 | 날짜: 2024-01-12      │
├─────────────────────────────────────────┤
│ 내용: 이 프로젝트는 ...                 │
│                                         │
│ 📎 첨부 파일 (2개):                     │
│   ├─ project.zip (2.5MB)   [다운로드]  │
│   └─ guide.pdf (512KB)     [다운로드]   │
└─────────────────────────────────────────┘
```

#### 🔗 파일 저장 구조

```
【 파일 첨부 데이터 흐름 】

사용자 컴퓨터              웹서버
┌──────────────┐         ┌─────────────────┐
│ photo.jpg    │         │ uploads/files/  │
│ (100KB)      │    ─→   │ 2024011_1_.jpg  │ ← 안전한 이름으로 변환
└──────────────┘         └─────────────────┘
                                 │
                                 ↓
                         데이터베이스
                         ┌─────────────────────────┐
                         │ attachments 테이블     │
                         │ original_name: photo.. │
                         │ stored_name: 2024011..│
                         │ file_size: 102400     │
                         └─────────────────────────┘
```

**왜 파일명을 바꾸나요?**

```
원본 파일명: "내 사진.jpg"
문제점:
  1. 특수문자/한글 때문에 경로 오류 발생
  2. 같은 이름의 파일이 겹칠 수 있음
  3. 보안: 파일 구조가 노출될 수 있음

해결책:
  저장 파일명: "2024011_1_photo.jpg"
  → 시간 + 게시글ID + 원본 파일명
  → 안전하고 유일한 이름 보장
```

### 1-2 테이블 설계

**attachments 테이블** (첨부 파일 정보)

| 컬럼명 | 타입 | 설명 |
|--------|------|------|
| `id` | INT | 파일 ID (자동 증가) |
| `post_id` | INT | 어느 게시글에 첨부된 파일 |
| `original_name` | VARCHAR | 사용자가 업로드한 원본 파일명 |
| `stored_name` | VARCHAR | 서버에 저장된 파일명 |
| `file_size` | INT | 파일 크기 (바이트) |
| `created_at` | TIMESTAMP | 업로드 날짜 |

```sql
CREATE TABLE attachments (
    id INT AUTO_INCREMENT PRIMARY KEY,
    post_id INT NOT NULL,
    original_name VARCHAR(255) NOT NULL,
    stored_name VARCHAR(255) NOT NULL,
    file_size INT NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (post_id) REFERENCES posts(id) ON DELETE CASCADE
);
```

**데이터 예시**:

```
┌─────┬─────────┬──────────────┬──────────────┬────────────┐
│ id  │post_id  │original_name │ stored_name  │ file_size  │
├─────┼─────────┼──────────────┼──────────────┼────────────┤
│ 1   │ 1       │ photo.jpg    │ 2024011_1... │ 102400     │
│ 2   │ 1       │ guide.pdf    │ 2024011_1... │ 524288     │
│ 3   │ 2       │ report.docx  │ 2024012_2... │ 1048576    │
└─────┴─────────┴──────────────┴──────────────┴────────────┘

사용자는 original_name 보여줌
시스템은 stored_name로 실제 파일 접근
```

### 1-3 데이터베이스 생성

```sql
USE board_db;

-- attachments 테이블 생성
CREATE TABLE attachments (
    id INT AUTO_INCREMENT PRIMARY KEY,
    post_id INT NOT NULL,
    original_name VARCHAR(255) NOT NULL,
    stored_name VARCHAR(255) NOT NULL,
    file_size INT NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (post_id) REFERENCES posts(id) ON DELETE CASCADE
);

-- 디렉토리 생성 (명령줄에서)
-- mkdir -p uploads/files
-- chmod 777 uploads/files
```

---

## 2️⃣ 파일 첨부 기능 구현

### 2-1 전체 흐름 이해

```
【 파일 처리 전체 과정 】

1️⃣ write.php
   ├─ 사용자가 파일 선택
   └─ form에서 POST 전송 (enctype="multipart/form-data")

2️⃣ uploadFile() 함수 실행
   ├─ 파일 크기 검증 (10MB 이하?)
   ├─ 확장자 검증 (jpg, pdf, txt 등?)
   ├─ 파일명 변환 (안전한 이름)
   └─ 서버에 파일 저장

3️⃣ 데이터베이스에 저장
   └─ INSERT INTO attachments

4️⃣ view.php에서 표시
   └─ 다운로드 링크 표시

5️⃣ download.php에서 다운로드
   └─ 원본 파일명으로 사용자에게 제공
```

### 2-2 upload_file.php (파일 업로드 함수)

**목적**: 파일을 안전하게 검증하고 저장하는 함수 정의

```php
<?php

// uploadFile() 함수
// 목적: 업로드된 파일을 검증하고 안전하게 저장
// 입력: $file (업로드된 파일), $post_id (게시글 ID)
// 출력: ['original_name' => ..., 'stored_name' => ..., 'file_size' => ...]
function uploadFile($file, $post_id) {
    // 파일 업로드 디렉토리 설정
    $upload_dir = __DIR__ . '/uploads/files/';
    
    // 디렉토리가 없으면 생성
    // is_dir(): 디렉토리가 있는지 확인
    if (!is_dir($upload_dir)) {
        // mkdir(): 새 디렉토리 생성 (0755는 권한)
        mkdir($upload_dir, 0755, true);
    }
    
    // ===== 1단계: 파일 크기 검증 =====
    // 최대 파일 크기: 10MB
    $max_size = 10 * 1024 * 1024; // 10MB를 바이트로 변환
    
    // $file['size']: 업로드된 파일의 크기 (바이트 단위)
    if ($file['size'] > $max_size) {
        throw new Exception("파일 크기는 10MB 이하여야 합니다");
    }
    
    // ===== 2단계: 확장자 검증 =====
    // pathinfo(): 파일명에서 확장자를 추출하는 함수
    // 예: "photo.jpg" → "jpg"
    // PATHINFO_EXTENSION: 확장자만 추출
    $allowed_ext = ['jpg', 'jpeg', 'png', 'gif', 'pdf', 'doc', 'docx', 'txt'];
    
    $file_ext = strtolower(pathinfo($file['name'], PATHINFO_EXTENSION));
    
    // in_array(): 배열에 값이 있는지 확인
    if (!in_array($file_ext, $allowed_ext)) {
        throw new Exception("허용되지 않는 파일 형식입니다. 허용: " . implode(', ', $allowed_ext));
    }
    
    // ===== 3단계: 안전한 파일명 생성 =====
    // 파일명을 변환하는 이유:
    //   1. 원본 파일명이 특수문자/한글일 수 있음
    //   2. 같은 이름의 파일이 중복될 수 있음
    //   3. 보안 (실제 파일 구조 숨김)
    
    // time(): 현재 시간 (유닉스 타임스탬프 - 1970년부터의 초)
    // 예: time() = 1704921600
    $stored_name = time() . '_' . $post_id . '_' . basename($file['name']);
    
    // ===== 4단계: 파일 저장 =====
    // move_uploaded_file(): PHP가 임시로 저장한 파일을
    //                      최종 위치로 이동
    // $file['tmp_name']: PHP가 임시로 저장한 경로
    // $file_path: 최종 저장 경로
    
    $file_path = $upload_dir . $stored_name;
    
    if (!move_uploaded_file($file['tmp_name'], $file_path)) {
        throw new Exception("파일 업로드에 실패했습니다");
    }
    
    // 파일 정보 반환
    // 반환된 정보를 다시 write.php에서 사용
    return [
        'original_name' => $file['name'],      // "photo.jpg"
        'stored_name' => $stored_name,         // "1704921600_1_photo.jpg"
        'file_size' => $file['size']           // 102400
    ];
}

?>
```

**함수 작동 예시**:

```
uploadFile 함수 호출 시:

입력:
  $file['name'] = "photo.jpg"
  $file['size'] = 102400 바이트
  $post_id = 1

실행:
  1. 크기 검증: 102400 < 10485760 ✅
  2. 확장자 검증: "jpg" in allowed_ext ✅
  3. 파일명 변환: "1704921600_1_photo.jpg"
  4. 파일 저장: uploads/files/1704921600_1_photo.jpg

출력:
  [
    'original_name' => 'photo.jpg',
    'stored_name' => '1704921600_1_photo.jpg',
    'file_size' => 102400
  ]
```

### 2-3 write.php 수정 (파일 업로드 추가)

기존 write.php에 **파일 첨부 기능** 추가:

```php
<?php

require 'config.php';
require 'upload_file.php';  // ← uploadFile 함수 포함

if (!isset($_SESSION['user_id'])) {
    header("Location: login.php");
    exit;
}

$error = '';

if ($_SERVER['REQUEST_METHOD'] === 'POST') {
    try {
        $title = htmlspecialchars(trim($_POST['title'] ?? ''));
        $content = htmlspecialchars(trim($_POST['content'] ?? ''));
        $user_id = $_SESSION['user_id'];
        
        if (empty($title) || empty($content)) {
            throw new Exception("제목과 내용을 입력하세요");
        }
        
        // 게시글 저장
        $sql = "INSERT INTO posts (user_id, title, content, views) VALUES (?, ?, ?, 0)";
        $stmt = $pdo->prepare($sql);
        $stmt->execute([$user_id, $title, $content]);
        
        // lastInsertId(): 방금 INSERT한 행의 ID 반환
        // 파일을 이 게시글에 연결하기 위해 필요
        $post_id = $pdo->lastInsertId();
        
        // ===== 파일 첨부 처리 =====
        // $_FILES: PHP에서 업로드된 파일 정보를 담는 배열
        if (!empty($_FILES) && isset($_FILES['files'])) {
            // $_FILES['files'] 구조:
            // [
            //   'name' => ['file1.jpg', 'file2.pdf', ...],
            //   'tmp_name' => [...],
            //   'size' => [...],
            //   'error' => [...]
            // ]
            
            $files = $_FILES['files'];
            
            // 여러 파일을 반복 처리
            for ($i = 0; $i < count($files['name']); $i++) {
                // 파일이 선택되지 않은 경우 건너뛰기
                if (empty($files['name'][$i])) {
                    continue;
                }
                
                // 파일 정보 정리
                // 배열의 각 요소에서 인덱스 $i번째 추출
                $file = [
                    'name' => $files['name'][$i],
                    'tmp_name' => $files['tmp_name'][$i],
                    'size' => $files['size'][$i],
                    'error' => $files['error'][$i]
                ];
                
                try {
                    // uploadFile() 함수 호출
                    // 파일 검증 + 저장 + 정보 반환
                    $uploaded = uploadFile($file, $post_id);
                    
                    // 데이터베이스에 파일 정보 저장
                    // INSERT INTO attachments
                    $file_sql = "INSERT INTO attachments (post_id, original_name, stored_name, file_size) 
                                 VALUES (?, ?, ?, ?)";
                    $file_stmt = $pdo->prepare($file_sql);
                    $file_stmt->execute([
                        $post_id,
                        $uploaded['original_name'],
                        $uploaded['stored_name'],
                        $uploaded['file_size']
                    ]);
                } catch (Exception $e) {
                    // 한 파일이 실패해도 다른 파일은 계속 처리
                    // 또는 여기서 throw하면 전체 작업 취소
                    continue; // 다음 파일로
                }
            }
        }
        
        // 게시글 작성 완료
        header("Location: view.php?id=$post_id");
        exit;
        
    } catch (Exception $e) {
        $error = $e->getMessage();
    }
}

?>

<!DOCTYPE html>
<html>
<head>
    <title>게시글 작성</title>
    <style>
        body { font-family: '맑은 고딕'; max-width: 800px; margin: 50px auto; padding: 20px; }
        h1 { color: navy; }
        form { background: #f5f5f5; padding: 20px; }
        input, textarea { width: 100%; padding: 8px; margin: 8px 0; border: 1px solid #ddd; }
        textarea { height: 300px; }
        button { background: navy; color: white; padding: 10px 20px; border: none; cursor: pointer; }
        .error { color: red; padding: 8px; background: #ffe6e6; }
        .info { color: #666; font-size: 12px; }
        a { color: navy; text-decoration: none; }
    </style>
</head>
<body>

<h1>✍️ 게시글 작성</h1>

<?php if ($error): ?>
    <div class="error"><?php echo htmlspecialchars($error); ?></div>
<?php endif; ?>

<form method="POST" enctype="multipart/form-data">
    <!-- enctype="multipart/form-data"
         목적: 파일 업로드를 위한 폼 인코딩 방식 지정
         기본값은 "application/x-www-form-urlencoded"인데,
         파일 업로드 시에는 반드시 multipart/form-data로 설정 -->
    
    <input type="text" name="title" placeholder="제목을 입력하세요" required>
    
    <textarea name="content" placeholder="내용을 입력하세요" required></textarea>
    
    <div>
        <label>파일 첨부 (선택)</label>
        <!-- multiple: 여러 파일 동시 선택 가능 -->
        <input type="file" name="files[]" multiple>
        <p class="info">허용 확장자: jpg, jpeg, png, gif, pdf, doc, docx, txt<br>
        최대 파일 크기: 10MB</p>
    </div>
    
    <button type="submit">게시글 등록</button>
</form>

<a href="list.php">← 목록으로</a>

</body>
</html>
```

### 2-4 view.php 수정 (파일 다운로드 링크)

기존 view.php에 **파일 다운로드 섹션** 추가:

```php
<?php
// ... 기존 게시글 표시 코드 ...

// 첨부 파일 조회
// SELECT ... FROM attachments WHERE post_id = ?
// 목적: 이 게시글에 첨부된 모든 파일을 조회
// ORDER BY created_at DESC: 최신 파일부터 표시
$attachments_sql = "SELECT id, original_name, stored_name, file_size, created_at 
                    FROM attachments 
                    WHERE post_id = ? 
                    ORDER BY created_at DESC";
$attachments_stmt = $pdo->prepare($attachments_sql);
$attachments_stmt->execute([$id]);
$attachments = $attachments_stmt->fetchAll(PDO::FETCH_ASSOC);

?>

<!-- 게시글 내용 표시 (기존 코드) -->

<!-- 첨부 파일 섹션 -->
<?php if (!empty($attachments)): ?>
    <hr>
    <h3>📎 첨부 파일 (<?php echo count($attachments); ?>)</h3>
    <ul>
        <?php foreach ($attachments as $attachment): ?>
            <li>
                <!-- 사용자에게는 original_name 표시 -->
                <?php echo htmlspecialchars($attachment['original_name']); ?>
                
                <!-- 파일 크기 표시 (바이트 → KB 변환) -->
                (<?php echo number_format($attachment['file_size'] / 1024, 1); ?> KB)
                
                <!-- 다운로드 링크 -->
                <a href="download.php?id=<?php echo $attachment['id']; ?>">[다운로드]</a>
                
                <!-- 본인의 파일만 삭제 가능 -->
                <?php if (isset($_SESSION['user_id']) && $_SESSION['user_id'] == $post['user_id']): ?>
                    <a href="delete_attachment.php?id=<?php echo $attachment['id']; ?>&post_id=<?php echo $id; ?>" 
                       onclick="return confirm('삭제하시겠습니까?');">[삭제]</a>
                <?php endif; ?>
            </li>
        <?php endforeach; ?>
    </ul>
<?php endif; ?>
```

### 2-5 download.php (파일 다운로드) ⭐ 안정적 버전

```php
<?php

require 'config.php';

try {
    // 1️⃣ 로그인 확인
    if (!isset($_SESSION['user_id'])) {
        header("Location: login.php");
        exit;
    }
    
    // 2️⃣ 파일 ID 받기 및 검증
    $file_id = isset($_GET['id']) ? intval($_GET['id']) : 0;
    
    if (!$file_id) {
        throw new Exception("파일을 찾을 수 없습니다");
    }
    
    // 3️⃣ 데이터베이스에서 파일 정보 조회
    $sql = "SELECT id, original_name, stored_name, file_size FROM attachments WHERE id = ?";
    $stmt = $pdo->prepare($sql);
    $stmt->execute([$file_id]);
    $file = $stmt->fetch(PDO::FETCH_ASSOC);
    
    if (!$file) {
        throw new Exception("파일 정보를 찾을 수 없습니다");
    }
    
    // 4️⃣ 파일 경로 설정
    $file_path = __DIR__ . '/uploads/files/' . $file['stored_name'];
    
    // 5️⃣ 파일 존재 및 읽기 가능 확인
    if (!is_file($file_path)) {
        throw new Exception("서버에 파일이 없습니다");
    }
    
    if (!is_readable($file_path)) {
        throw new Exception("파일을 읽을 수 없습니다");
    }
    
    // 6️⃣ 파일 크기 확인
    $file_size = filesize($file_path);
    if (!$file_size) {
        throw new Exception("파일 크기를 확인할 수 없습니다");
    }
    
    // 7️⃣ 세션 종료 (대용량 파일 다운로드 시 필요)
    session_write_close();
    
    // 8️⃣ HTTP 헤더 설정
    // 중요: 다른 모든 출력 전에 헤더를 먼저 설정해야 함
    header('Content-Description: File Transfer');
    header('Content-Type: application/octet-stream');
    header('Content-Disposition: attachment; filename="' . $file['original_name'] . '"');
    header('Content-Length: ' . $file_size);
    header('Cache-Control: no-cache, must-revalidate');
    header('Pragma: no-cache');
    header('Expires: 0');
    
    // 9️⃣ 파일 전송
    readfile($file_path);
    exit;
    
} catch (Exception $e) {
    // 에러 처리
    if (ob_get_contents()) {
        ob_end_clean();
    }
    
    if (!headers_sent()) {
        http_response_code(500);
    }
    
    echo "❌ 다운로드 실패: " . htmlspecialchars($e->getMessage());
    exit;
}

?>
```

**핵심 포인트:**

```
✅ 1️⃣ intval() 사용
   - $_GET['id']를 정수로 변환
   - SQL 인젝션 방지

✅ 2️⃣ 파일 검증 강화
   - is_file(): 파일인지 확인
   - is_readable(): 읽기 가능한지 확인
   - filesize(): 파일 크기 확인

✅ 3️⃣ session_write_close()
   - 세션 파일 잠금 해제
   - 대용량 파일 다운로드 안정성 향상

✅ 4️⃣ 간단한 헤더 설정
   - Content-Type: application/octet-stream
   - Content-Disposition: attachment; filename="..."
   - 모든 브라우저 호환

✅ 5️⃣ 개선된 에러 처리
   - ob_get_contents() 확인
   - headers_sent() 확인
   - http_response_code() 설정
```

**다운로드 흐름도**:

```
【 파일 다운로드 9단계 프로세스 】

1️⃣ 사용자가 [다운로드] 클릭
2️⃣ download.php?id=1 요청 발송
3️⃣ 로그인 확인 ($_SESSION['user_id'])
4️⃣ 파일 ID 정수로 검증 (intval)
5️⃣ 데이터베이스에서 파일 정보 조회
6️⃣ 파일 존재 및 읽기 가능 확인
7️⃣ HTTP 헤더 설정
8️⃣ 세션 종료 (session_write_close)
9️⃣ readfile()로 파일 전송

결과: 사용자 컴퓨터에 파일 다운로드됨
```



**다운로드 실패 시 해결 방법:**

```
【 문제 1: "파일을 찾을 수 없습니다" 에러 】
원인: 데이터베이스에 파일 정보가 없거나 파일 ID가 잘못됨
해결:
  1. 게시글 view.php에서 [다운로드] 링크 확인
  2. download.php?id=1 형태로 ID가 전달되는지 확인
  3. 데이터베이스의 attachments 테이블 확인
     SELECT * FROM attachments WHERE id=1;

【 문제 2: "파일이 없습니다" 에러 】
원인: 물리적 파일이 서버에 없음
해결:
  1. uploads/files/ 디렉토리 확인
     ls -la boards/uploads/files/
  2. 파일 권한 확인 (읽기 가능해야 함)
     chmod 644 boards/uploads/files/*
  3. file_uploads.php에서 파일이 제대로 저장되었는지 확인

【 문제 3: 다운로드 진행이 안 됨 】
원인: 다운로드 헤더 설정이 변경되었거나 출력 버퍼 문제
해결:
  1. PHP 파일에 BOM(Byte Order Mark) 없는지 확인
  2. download.php 맨 앞에 공백이나 echo가 없는지 확인
  3. ob_clean(), flush() 추가되어 있는지 확인

【 문제 4: 한글 파일명이 깨짐 】
원인: 파일명 인코딩 문제
해결:
  ✅ RFC 2231 인코딩 사용 (이미 적용됨)
     Content-Disposition: attachment; filename*=UTF-8''파일명
  ✅ 브라우저에서 자동으로 올바르게 표시됨

【 문제 5: 로그인 안 하면 다운로드 안 됨 】
원인: 보안상 로그인 확인 추가됨 (정상)
해결:
  login.php에서 로그인 (user1 / password123)
  그 후 다운로드 가능
```

---

### 2-6 delete_attachment.php (파일 삭제)

```php
<?php

require 'config.php';

try {
    $file_id = $_GET['id'] ?? null;
    $post_id = $_GET['post_id'] ?? null;
    
    if (!$file_id || !$post_id) {
        throw new Exception("잘못된 요청입니다");
    }
    
    // 파일 정보 조회
    // 삭제하기 전에 파일 정보를 먼저 조회
    $sql = "SELECT stored_name FROM attachments WHERE id = ?";
    $stmt = $pdo->prepare($sql);
    $stmt->execute([$file_id]);
    
    $file = $stmt->fetch(PDO::FETCH_ASSOC);
    
    if (!$file) {
        throw new Exception("파일을 찾을 수 없습니다");
    }
    
    // 서버에서 파일 삭제
    $file_path = __DIR__ . '/uploads/files/' . $file['stored_name'];
    
    // file_exists(): 파일 존재 확인
    if (file_exists($file_path)) {
        // unlink(): 파일 삭제
        // 목적: 실제 파일을 하드드라이브에서 제거
        unlink($file_path);
    }
    
    // 데이터베이스에서 파일 정보 삭제
    // DELETE FROM attachments WHERE id = ?
    // 목적: 데이터베이스에서 파일 기록 제거
    $delete_sql = "DELETE FROM attachments WHERE id = ?";
    $delete_stmt = $pdo->prepare($delete_sql);
    $delete_stmt->execute([$file_id]);
    
    // 게시글 페이지로 돌아가기
    header("Location: view.php?id=$post_id");
    exit;
    
} catch (Exception $e) {
    die("삭제 실패: " . htmlspecialchars($e->getMessage()));
}

?>
```

---

## 3️⃣ 과제

### 필수 과제

```
1. 데이터베이스 생성
   - board_db에 attachments 테이블 생성
   - uploads/files 디렉토리 생성

2. 파일 업로드 기능
   - write.php에 파일 업로드 기능 추가
   - 여러 파일 동시 업로드 가능 확인

3. 파일 다운로드
   - download.php 구현 및 테스트
   - 파일 다운로드 시 원본 파일명 유지 확인

4. 파일 삭제
   - delete_attachment.php 구현 및 테스트
   - 본인의 게시글의 파일만 삭제 가능하도록 제한
```

### 선택 과제

```
1. 파일 크기 제한을 10MB에서 5MB로 변경
2. 허용 확장자 추가 (예: mp4 추가)
3. 파일 업로드 시 MIME 타입 검증 추가
```

---

## 4️⃣ 핵심 개념

### 파일 검증

**왜 검증이 필요한가?**

```
검증 없이 업로드하면:
  - 악성 파일(바이러스) 업로드 가능
  - 과도하게 큰 파일로 서버 가득 참
  - 실행 파일 (.exe) 업로드 가능

→ 데이터 손상 / 보안 위협
```

**검증 방법**:

```php
// 1. 파일 크기 검증
if ($file['size'] > 10 * 1024 * 1024) {
    throw new Exception("파일이 너무 큽니다");
}

// 2. 확장자 검증
$allowed = ['jpg', 'pdf', 'txt'];
$ext = pathinfo($file['name'], PATHINFO_EXTENSION);
if (!in_array($ext, $allowed)) {
    throw new Exception("허용되지 않는 형식입니다");
}
```

### 안전한 파일명

**문제**: 원본 파일명을 그대로 사용

```
problem.jpg          ← 다른 사용자도 이 이름으로 업로드할 수 있음
내 프로필.jpg      ← 특수문자/한글 때문에 경로 오류 발생
../../../etc/passwd ← 경로 조작으로 시스템 파일 접근 시도
```

**해결책**: 시스템이 파일명 생성

```php
// time() = 1704921600 (현재 시간)
// $post_id = 1 (게시글 ID)
// basename() = 경로 제거, 파일명만 추출
$stored_name = time() . '_' . $post_id . '_' . basename($file['name']);

결과: 1704921600_1_photo.jpg
→ 유일하고 안전한 파일명!
```

### 파일 다운로드

**HTTP 헤더의 역할**:

```
브라우저에 지시사항 전달:

1. Content-Type: application/octet-stream
   → "이것은 일반 파일입니다" (텍스트/이미지 아님)

2. Content-Disposition: attachment; filename="..."
   → "사용자가 저장하도록 하세요"
   → filename으로 저장 파일명 지정

3. Content-Length: 파일크기
   → 다운로드 진행률 표시
```

**예시**:

```
원본 파일명: photo.jpg (서버 내부명: 1704921600_1_photo.jpg)

사용자가 다운로드 → download.php로 요청
                      ↓
                stored_name으로 파일 찾음
                      ↓
                HTTP 헤더에 original_name 지정
                      ↓
                readfile()로 전송
                      ↓
                사용자 PC에 photo.jpg로 저장됨
```

---



---

## 📋 최종 점검 체크리스트

파일 다운로드가 정상 작동하는지 확인하세요:

```
【 설정 확인 】
☐ uploads/files/ 디렉토리 생성됨
☐ 디렉토리 쓰기 권한 설정됨 (chmod 777)
☐ PHP의 upload_tmp_dir 설정 확인

【 파일 업로드 확인 】
☐ 게시글 작성 시 파일 업로드 성공
☐ 업로드된 파일이 uploads/files/에 저장됨
☐ 데이터베이스의 attachments 테이블에 기록됨

SQL 확인:
SELECT * FROM attachments;
→ stored_name, original_name, file_size 값 확인

【 파일 시스템 확인 】
☐ 저장된 파일이 실제로 존재
  ls -la boards/uploads/files/
☐ 파일 읽기 권한 있음 (644 이상)
  chmod 644 boards/uploads/files/*

【 데이터베이스 확인 】
☐ attachments 테이블 구조
  DESC attachments;
☐ 테이블에 데이터 존재
  SELECT COUNT(*) FROM attachments;

【 다운로드 테스트 】
☐ download.php?id=1 직접 접속 시도
☐ 브라우저 개발자 도구에서 응답 헤더 확인
  - Content-Type: application/octet-stream
  - Content-Disposition: attachment; ...

【 로그 확인 】
☐ 웹 서버 에러 로그 확인
  tail -f /var/log/apache2/error.log
☐ PHP 에러 로그 확인
  tail -f /var/log/php_errors.log

```

---

## 🔧 파일 다운로드 작동 흐름도

```
【 파일 다운로드 시퀀스 】

1️⃣ 사용자가 [다운로드] 클릭
   view.php에 표시된 링크

2️⃣ download.php?id=X 요청 발송
   GET 파라미터로 파일 ID 전달

3️⃣ 로그인 확인
   $_SESSION['user_id'] 확인
   → 로그인하지 않으면 login.php로 리다이렉트

4️⃣ 파일 정보 조회
   SELECT stored_name, original_name, file_size
   FROM attachments WHERE id = ?

5️⃣ 파일 존재 확인
   file_exists($file_path) 체크
   → 파일이 없으면 "파일이 없습니다" 에러

6️⃣ HTTP 헤더 설정
   Content-Type: application/octet-stream
   Content-Length: 파일크기
   Content-Disposition: attachment; filename=...

7️⃣ 출력 버퍼 정리
   ob_clean(), flush()

8️⃣ 파일 전송
   readfile($file_path)

9️⃣ 브라우저에서 다운로드
   원본 파일명으로 자동 저장됨
```

---



---

## 🎯 파일 다운로드 빠른 팁

### ✅ download.php가 작동하지 않을 때

**1️⃣ 로그인 확인**
```
→ login.php에서 로그인했는지 확인 (user1 / password123)
→ $_SESSION['user_id']가 설정되어야 함
```

**2️⃣ 파일 업로드 확인**
```bash
# 업로드된 파일이 실제로 존재하는지 확인
ls -la boards/uploads/files/
chmod 644 boards/uploads/files/*
```

**3️⃣ 데이터베이스 확인**
```sql
-- 파일 정보가 저장되었는지 확인
SELECT * FROM attachments LIMIT 5;

-- 저장된 파일명 확인
SELECT original_name, stored_name FROM attachments;
```

**4️⃣ PHP 에러 확인**
```bash
# PHP 에러 로그 보기
tail -f /var/log/php_errors.log

# download.php 테스트
curl -I http://localhost/boards/download.php?id=1
```

**5️⃣ download.php 헤더 확인**
- 맨 앞에 공백이나 BOM이 없는지 확인
- `<?php` 직전에 아무 문자도 없어야 함

### 📋 정상 작동 확인

```
1️⃣ 게시글 작성 (파일 첨부)
2️⃣ view.php에서 파일 목록 표시됨
3️⃣ [다운로드] 링크 클릭
4️⃣ download.php?id=1 형태의 URL 호출
5️⃣ 파일이 브라우저에 다운로드됨
```

---

## 5️⃣ 주의사항

1. **디렉토리 권한**: uploads/files 디렉토리에 쓰기 권한 필요 (chmod 777)
2. **파일 검증**: 확장자뿐만 아니라 크기도 반드시 확인
3. **경로 검증**: 악의적인 경로 조작 방지 (basename() 사용)
4. **파일 처리**: 삭제 전에 파일 존재 확인 (file_exists())

---

수고했습니다.

조정현 교수(peterchokr@gmail.com)
영남이공대학교

